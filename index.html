<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>التوزيع المتوازن للعدادات - خوارزمية التوازن الذكي</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }

        .input-section {
            background: #f8f9ff;
            border: 2px solid #e3f2fd;
        }

        .results-section {
            background: #f1f8e9;
            border: 2px solid #c8e6c9;
            display: none;
        }

        .section h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 3px solid #4facfe;
            padding-bottom: 10px;
        }

        .form-group {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr auto;
            gap: 15px;
            align-items: end;
            margin-bottom: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .form-group label {
            font-weight: bold;
            color: #555;
            margin-bottom: 5px;
            display: block;
        }

        .form-group input, .form-group select {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .form-group input::placeholder {
            color: #999;
            font-style: italic;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .btn-add {
            background: #4caf50;
            color: white;
        }

        .btn-add:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .btn-remove {
            background: #f44336;
            color: white;
            padding: 8px 12px;
            font-size: 14px;
        }

        .btn-remove:hover {
            background: #da190b;
        }

        .btn-calculate {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            font-size: 18px;
            margin: 20px auto;
            display: block;
            min-width: 200px;
        }

        .btn-calculate:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        .btn-export {
            background: #ff9800;
            color: white;
            margin-left: 10px;
        }

        .btn-export:hover {
            background: #e68900;
        }

        .meters-list {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .meter-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin-bottom: 10px;
            background: #f5f5f5;
            border-radius: 6px;
            border-right: 4px solid #4facfe;
        }

        .meter-info {
            flex-grow: 1;
        }

        .meter-info strong {
            color: #333;
            font-size: 16px;
        }

        .meter-details {
            color: #666;
            font-size: 14px;
            margin-top: 5px;
        }

        .alert {
            padding: 15px;
            margin: 20px 0;
            border-radius: 6px;
            font-weight: bold;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4facfe;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .transformer-section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #4facfe;
        }

        .breaker-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .breaker-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #4facfe;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }

        .progress-fill {
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .progress-balanced { background: #4caf50; }
        .progress-good { background: #8bc34a; }
        .progress-medium { background: #ff9800; }
        .progress-high { background: #f44336; }
        .progress-low { background: #4caf50; }
        .progress-overload { background: #ff5722; }

        .balance-indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 5px;
        }

        .balance-excellent {
            background: #4caf50;
            color: white;
        }

        .balance-good {
            background: #8bc34a;
            color: white;
        }

        .balance-fair {
            background: #ff9800;
            color: white;
        }

        .balance-poor {
            background: #f44336;
            color: white;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .results-table th {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 15px;
            text-align: center;
            font-weight: bold;
        }

        .results-table td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }

        .results-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .results-table tr:hover {
            background: #e3f2fd;
            transition: background 0.3s;
        }

        .load-high { background-color: #ffebee !important; }
        .load-medium { background-color: #fff8e1 !important; }
        .load-low { background-color: #e8f5e8 !important; }

        .overloaded {
            background-color: #ff5722 !important;
            color: white !important;
            font-weight: bold;
        }

        .overloaded td {
            border-color: #d32f2f !important;
        }

        .summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .summary-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-top: 4px solid #4facfe;
        }

        .summary-card h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .summary-card .value {
            font-size: 2em;
            font-weight: bold;
            color: #4facfe;
        }

        .meter-details-cell {
            text-align: right !important;
            padding: 15px !important;
            line-height: 1.8;
        }

        .meter-detail-item {
            display: inline-block;
            background: #f0f8ff;
            border: 2px solid #4facfe;
            border-radius: 8px;
            padding: 8px 12px;
            margin: 3px;
            font-weight: bold;
            color: #2c5aa0;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .meter-detail-item .count {
            font-size: 18px;
            color: #1976d2;
        }

        .meter-detail-item .multiply {
            font-size: 16px;
            color: #666;
            margin: 0 2px;
        }

        .meter-detail-item .capacity {
            font-size: 14px;
            color: #d32f2f;
        }

        .meter-type-badge {
            background: #e3f2fd;
            color: #1976d2;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            margin-left: 5px;
        }

        .mixed-load-indicator {
            background: linear-gradient(45deg, #4caf50, #ff9800, #2196f3);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            margin-right: 5px;
        }

        .transformer-overload-warning {
            background: #fff3cd;
            border: 2px solid #ffc107;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: bold;
        }

        .transformer-safe {
            border-left-color: #28a745;
        }

        .transformer-warning {
            border-left-color: #ffc107;
        }

        .transformer-danger {
            border-left-color: #dc3545;
        }

        @media (max-width: 768px) {
            .form-group {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .header h1 {
                font-size: 1.8em;
            }
            
            .content {
                padding: 15px;
            }
            
            .summary {
                grid-template-columns: 1fr;
            }

            .summary-grid {
                grid-template-columns: 1fr;
            }

            .breaker-grid {
                grid-template-columns: 1fr;
            }

            .meter-details-cell {
                text-align: center !important;
            }

            .meter-detail-item {
                display: block;
                margin: 5px 0;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>⚖️ التوزيع المتوازن للعدادات</h1>
            <p>خوارزمية التوازن الذكي - حد أقصى 80% لكل محول</p>
        </div>

        <div class="content">
            <div class="section input-section">
                <h2>📊 إدخال بيانات العدادات</h2>
                
                <div class="form-group">
                    <div>
                        <label for="meterType">نوع العداد:</label>
                        <select id="meterType">
                                  <option value="C1">C1 - سكني عادي (فلل، شقق، دوبلكس...)</option>
                            <option value="C2">C2 - محلات تجارية</option>
                            <option value="C3">C3 - شقق مفروشة / سكن عمال</option>
                            <option value="C4">C4 - فنادق</option>
                            <option value="C5">C5 - مولات / مراكز تسوق</option>
                            <option value="C6">C6 - مطاعم / مقاهي</option>
                            <option value="C7">C7 - مكاتب (حكومية/تجارية)</option>
                            <option value="C8">C8 - مدارس / حضانات</option>
                            <option value="C9">C9 - مساجد</option>
                            <option value="C10">C10 - ميزانين فندق</option>
                            <option value="C11">C11 - خدمات مشتركة في المباني</option>
                            <option value="C12">C12 - مرافق عامة (حمامات خارجية وغيرها)</option>
                            <option value="C13">C13 - مواقف سيارات داخلية</option>
                            <option value="C14">C14 - مواقف خارجية</option>
                            <option value="C15">C15 - إنارة شوارع</option>
                            <option value="C16">C16 - حدائق ومتنزهات</option>
                            <option value="C17">C17 - ساحات مفتوحة</option>
                            <option value="C18">C18 - مستشفيات / مرافق طبية</option>
                            <option value="C19">C19 - عيادات طبية</option>
                            <option value="C20">C20 - جامعات / معاهد عليا</option>
                            <option value="C21">C21 - صناعات خفيفة</option>
                            <option value="C22">C22 - ورش عمل</option>
                            <option value="C23">C23 - مخازن تبريد</option>
                            <option value="C24">C24 - مستودعات</option>
                            <option value="C25">C25 - قاعات مناسبات</option>
                            <option value="C26">C26 - منشآت ترفيهية</option>
                            <option value="C27">C27 - مزارع / منشآت زراعية</option>
                            <option value="C28">C28 - محطات وقود</option>
                            <option value="C29">C29 - مصانع كبرى</option>
                        </select>
                    </div>
                    <div>
                        <label for="meterCount">عدد العدادات:</label>
                        <input type="number" id="meterCount" min="1" placeholder="أدخل عدد العدادات">
                    </div>
                    <div>
                        <label for="meterCapacity">سعة العداد (A):</label>
                        <select id="meterCapacity">
                        <option value="20">20A</option>
                            <option value="30">30A</option>
                            <option value="40">40A</option>
                            <option value="50">50A</option>
                            <option value="70">70A</option>
                            <option value="100">100A</option>
                            <option value="125">125A</option>
                            <option value="150">150A</option>
                            <option value="200">200A</option>
                            <option value="250">250A</option>
                            <option value="300">300A</option>
                            <option value="400">400A</option>
                            <option value="500">500A</option>
                            <option value="600">600A</option>
                             <option value="800">800A</option>
                              <option value="1600">1600A</option>
                               <option value="2500">2500A</option>
                        </select>
                    </div>
                    <div>
                        <button class="btn btn-add" onclick="addMeter()">➕ إضافة</button>
                    </div>
                </div>

                <div class="meters-list" id="metersList">
                    <h3>📋 قائمة العدادات المضافة:</h3>
                    <div id="metersContainer"></div>
                </div>

                <button class="btn btn-export" onclick="addSampleData()" style="margin: 10px;">🎯 إضافة بيانات تجريبية</button>
                
                <button class="btn btn-calculate" onclick="calculateBalancedDistribution()">
                    ⚖️ حساب التوزيع المتوازن
                </button>

                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <p>جاري حساب التوزيع المتوازن مع خوارزمية التوازن الذكي...</p>
                </div>
            </div>

            <div class="section results-section" id="resultsSection">
                <h2>📈 نتائج التوزيع المتوازن</h2>
                
                <div class="summary-card">
                    <div class="summary-grid" id="summaryGrid"></div>
                </div>
                
                <div id="transformersSection"></div>
                
                <table class="results-table" id="resultsTable">
                    <thead>
                        <tr>
                            <th>المحول</th>
                            <th>رقم القاطع</th>
                            <th>نوع الأحمال</th>
                            <th>عدد العدادات</th>
                            <th>الحمل (A)</th>
                            <th>نسبة الاستخدام</th>
                            <th>مؤشر التوازن</th>
                            <th>تفاصيل العدادات</th>
                        </tr>
                    </thead>
                    <tbody id="resultsBody"></tbody>
                </table>

                <div style="margin-top: 20px; text-align: center;">
                    <button class="btn btn-export" onclick="exportToExcel()">📊 تصدير إلى Excel</button>
                    <button class="btn btn-export" onclick="printResults()">🖨️ طباعة</button>
                </div>
            </div>
        </div>
    </div>

    <script>














        // ثوابت النظام المحدثة
        const MAX_BREAKER_CAPACITY = 248;
        const TARGET_BREAKER_CAPACITY = 248; // الهدف (80% من 310)
        const TARGET_UTILIZATION = 75; // الهدف 75% للتوازن المثالي
        const BALANCE_TOLERANCE = 15; // تفاوت مقبول ±15%
        const MAX_TRANSFORMER_UTILIZATION = 80; // حد أقصى 80% لكل محول

        // بيانات المحولات - مع حساب الحد الأقصى 80%
        const TRANSFORMER_TYPES = [
            { 
                capacity: 500, 
                maxCurrent: 721, 
                breakers: 4, 
                name: '500 KVA', 
                maxLoad: 576.80, // 80% من الحد الأقصى
                safeLoad: 576.80, // 80% من maxLoad
                minLoad: 216
            },
            { 
                capacity: 1000, 
                maxCurrent: 1443, 
                breakers: 8, 
                name: '1000 KVA', 
                maxLoad: 1154.40, 
                safeLoad: 1154.30, // 80% من maxLoad
                minLoad: 433
            },
            { 
                capacity: 1500, 
                maxCurrent: 2164, 
                breakers: 10, 
                name: '1500 KVA', 
                maxLoad: 1731.20, 
                safeLoad: 1731.2, // 80% من maxLoad
                minLoad: 800 
            }
        ];

        const meterTypeNames = {
            'C1': 'سكني عادي', 'C2': 'محلات تجارية', 'C3': 'شقق مفروشة', 
            'C4': 'فنادق', 'C5': 'مولات', 'C6': 'مطاعم', 'C7': 'مكاتب', 
            'C8': 'مدارس', 'C9': 'مساجد', 'C15': 'إنارة شوارع'
        };

        const demandFactors = {
                'C1': 0.5,   // سكني عادي
            'C2': 0.6,   // محلات تجارية
            'C3': 0.6,  // شقق مفروشة
            'C4': 0.65,   // فنادق
            'C5': 0.6,   // مولات
            'C6': 0.6,  // مطاعم
            'C7': 0.6,  // مكاتب
            'C8': 0.7,   // مدارس
            'C9': 0.8,   // مساجد
            'C10': 0.65, // ميزانين فندق
            'C11': 0.7,  // خدمات مشتركة
            'C12': 0.65,  // مرافق عامة
            'C13': 0.7,  // مواقف داخلية
            'C14': 0.8, // مواقف خارجية
            'C15': 0.8,  // إنارة شوارع
            'C16': 0.7,  // حدائق
            'C17': 0.8,  // ساحات مفتوحة
            'C18': 0.7, // مستشفيات
            'C19': 0.6,  // عيادات
            'C20': 0.7, // جامعات
            'C21': 0.8,  // صناعات خفيفة
            'C22': 0.8, // ورش عمل
            'C23': 0.8,  // مخازن تبريد
            'C24': 0.6,  // مستودعات
            'C25': 0.7,  // قاعات مناسبات
            'C26': 0.7, // منشآت ترفيهية
            'C27': 0.8,  // مزارع
            'C28': 0.6,  // محطات وقود
            'C29': 0.8   // مصانع كبرى
        };

        // تصنيف الأحمال للخلط المتوازن
        const loadCategories = {
            'residential': ['C1', 'C3'],
            'commercial': ['C2', 'C4', 'C5', 'C6', 'C7'],
            'public': ['C8', 'C9'],
            'infrastructure': ['C15']
        };

        // أنماط التوقيت للتوازن
        const timePatterns = {
            'day': ['C2', 'C7', 'C8'],
            'night': ['C1', 'C3', 'C4', 'C6'],
            'mixed': ['C5', 'C9', 'C15']
        };

        let meters = [];
        let distributionResults = null;

        // حساب عامل التزامن المحسن
        function calculateCoincidenceFactor(N, meterType) {
            if (meterType === 'C2') return 1;
            if (N === 1) return 1;
            const sqrtN = Math.sqrt(N);
            return (0.67 + (0.33 / sqrtN)) / 1.25;
        }

        function getCategoryForType(type) {
            for (let category in loadCategories) {
                if (loadCategories[category].includes(type)) {
                    return category;
                }
            }
            return 'mixed';
        }

        function getTimePatternForType(type) {
            for (let pattern in timePatterns) {
                if (timePatterns[pattern].includes(type)) {
                    return pattern;
                }
            }
            return 'mixed';
        }
        
        // إضافة دالة لتحديد نوع القاطع المطلوب حسب سعة العداد
        function getBreakerRequirementForMeter(meterCapacity) {
            switch(meterCapacity) {
                case 500:
                    return { requiredBreakers: 2, breakerType: 'standard' }; // قاطعين عاديين
                case 600:
                    return { requiredBreakers: 2, breakerType: 'standard' }; // قاطعين عاديين
                case 800:
                    return { requiredBreakers: 2, breakerType: 'standard' }; // قاطعين عاديين
                case 1600:
                    return { requiredBreakers: 1, breakerType: '1600A' }; // قاطع 1600 أمبير
                case 2500:
                    return { requiredBreakers: 1, breakerType: '2500A' }; // قاطع 2500 أمبير
                default:
                    return { requiredBreakers: 1, breakerType: 'standard' }; // قاطع عادي للأحجام الأخرى
            }
        }

        // دالة للعثور على المحول الذي يحتوي على القاطع
        function findTransformerForBreaker(targetBreaker) {
            if (distributionResults && distributionResults.transformers) {
                for (let transformer of distributionResults.transformers) {
                    if (transformer.breakers.includes(targetBreaker)) {
                        return transformer;
                    }
                }
            }
            return null;
        }

        // دالة للعثور على أفضل قاطع ثاني لتوزيع الحمل
        function findBestSecondBreaker(breakers, halfLoad, excludeBreaker) {
            let bestBreaker = null;
            let bestScore = -1;
            
            for (let breaker of breakers) {
                if (breaker === excludeBreaker) continue;
                
                if (breaker.load + halfLoad <= MAX_BREAKER_CAPACITY) {
                    // حساب نقاط التوازن
                    const newUtilization = ((breaker.load + halfLoad) / MAX_BREAKER_CAPACITY) * 100;
                    const targetDiff = Math.abs(newUtilization - TARGET_UTILIZATION);
                    const score = Math.max(0, 100 - targetDiff);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestBreaker = breaker;
                    }
                }
            }
            
            return bestBreaker;
        }

        // دالة للعثور على أفضل قاطعين متاحين لتوزيع الحمل - هنا التعديل المطلوب
        function findBestTwoBreakers(breakers, halfLoad) {
            const availableBreakers = breakers.filter(breaker => 
                !breaker.dedicated && breaker.load + halfLoad <= MAX_BREAKER_CAPACITY
            );
            
            if (availableBreakers.length < 2) {
                return []; // لا يوجد قاطعين متاحين
            }
            
            let bestPair = [];
            let bestScore = -1;
            
            // تجربة كل الأزواج الممكنة
            for (let i = 0; i < availableBreakers.length; i++) {
                for (let j = i + 1; j < availableBreakers.length; j++) {
                    const breaker1 = availableBreakers[i];
                    const breaker2 = availableBreakers[j];
                    
                    // حساب النقاط لهذا الزوج
                    const score = calculatePairScore(breaker1, breaker2, halfLoad, breakers);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestPair = [breaker1, breaker2];
                    }
                }
            }
            
            return bestPair;
        }

        // دالة لحساب نقاط زوج من القواطع
        function calculatePairScore(breaker1, breaker2, halfLoad, allBreakers) {
            let score = 0;
            
            // حساب الاستخدام الجديد لكل قاطع
            const newUtilization1 = ((breaker1.load + halfLoad) / MAX_BREAKER_CAPACITY) * 100;
            const newUtilization2 = ((breaker2.load + halfLoad) / MAX_BREAKER_CAPACITY) * 100;
            
            // نقاط التوازن مع الهدف المثالي (75%)
            const targetDiff1 = Math.abs(newUtilization1 - TARGET_UTILIZATION);
            const targetDiff2 = Math.abs(newUtilization2 - TARGET_UTILIZATION);
            score += Math.max(0, 50 - targetDiff1) + Math.max(0, 50 - targetDiff2);
            
            // نقاط التوازن بين القاطعين نفسيهما
            const balanceBetweenPair = Math.abs(newUtilization1 - newUtilization2);
            score += Math.max(0, 30 - balanceBetweenPair);
            
            // نقاط التوازن العام مع باقي القواطع
            const avgLoad = allBreakers.reduce((sum, b) => sum + b.load, 0) / allBreakers.length;
            const balanceDiff1 = Math.abs((breaker1.load + halfLoad) - avgLoad);
            const balanceDiff2 = Math.abs((breaker2.load + halfLoad) - avgLoad);
            score += Math.max(0, 20 - balanceDiff1/2) + Math.max(0, 20 - balanceDiff2/2);
            
            // تفضيل القواطع الأقل ازدحاماً
            const totalMeters = breaker1.meters.length + breaker2.meters.length;
            if (totalMeters < 8) {
                score += 15;
            } else if (totalMeters > 12) {
                score -= 10;
            }
            
            // تفضيل القواطع المتتالية (للتنظيم)
            if (Math.abs(breaker1.number - breaker2.number) === 1) {
                score += 10;
            }
            
            return score;
        }

        // دالة للتحقق من توفر قاطعين مناسبين في المحول
        function checkTwoBreakersAvailability(transformer, halfLoad) {
            const availableBreakers = transformer.breakers.filter(breaker => 
                breaker.load + halfLoad <= MAX_BREAKER_CAPACITY
            );
            
            return availableBreakers.length >= 2;
        }

        function addMeter() {
            const type = document.getElementById('meterType').value;
            const count = parseInt(document.getElementById('meterCount').value);
            const capacity = parseInt(document.getElementById('meterCapacity').value);

            if (!count || count <= 0) {
                showError('يرجى إدخال عدد العدادات');
                return;
            }

            const demandFactor = demandFactors[type];
            const coincidenceFactor = calculateCoincidenceFactor(count, type);
            const cdlPerMeter = capacity * demandFactor;
            const totalCDL = count * cdlPerMeter * coincidenceFactor;

            const meterGroup = {
                id: Date.now(),
                type: type,
                typeName: meterTypeNames[type],
                count: count,
                capacity: capacity,
                demandFactor: demandFactor,
                coincidenceFactor: coincidenceFactor,
                cdlPerMeter: cdlPerMeter,
                totalCDL: totalCDL,
                category: getCategoryForType(type),
                timePattern: getTimePatternForType(type)
            };

            meters.push(meterGroup);
            updateMetersList();
            clearInputs();
            showSuccess('تم إضافة العداد بنجاح');
        }

        // تحديث قائمة العدادات
        function updateMetersList() {
            const container = document.getElementById('metersContainer');
            
            if (meters.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">لم يتم إضافة أي عدادات بعد</p>';
                return;
            }

            container.innerHTML = meters.map(meter => `
                <div class="meter-item">
                    <div class="meter-info">
                        <strong>${meter.count} × ${meter.typeName} (${meter.capacity}A)</strong>
                        <div class="meter-details">
                            معامل الطلب: ${meter.demandFactor.toFixed(3)} | 
                            معامل التزامن: ${meter.coincidenceFactor.toFixed(3)} | 
                            الحمل الإجمالي: ${meter.totalCDL.toFixed(1)}A
                        </div>
                    </div>
                    <button class="btn btn-remove" onclick="removeMeter(${meter.id})">🗑️ حذف</button>
                </div>
            `).join('');
        }

        function removeMeter(id) {
            meters = meters.filter(meter => meter.id !== id);
            updateMetersList();
            showSuccess('تم حذف العداد');
        }

        function clearInputs() {
            document.getElementById('meterCount').value = '';
        }

        function addSampleData() {
            if (confirm('هل تريد إضافة بيانات تجريبية؟')) {
                meters = [];
                
                const sampleData = [
                    { type: 'C1', count: 35, capacity: 30 },
                    { type: 'C2', count: 25, capacity: 70 },
                    { type: 'C1', count: 30, capacity: 50 },
                    { type: 'C6', count: 15, capacity: 100 },
                    { type: 'C3', count: 20, capacity: 40 },
                    { type: 'C7', count: 18, capacity: 50 }
                ];

                sampleData.forEach(data => {
                    const demandFactor = demandFactors[data.type];
                    const coincidenceFactor = calculateCoincidenceFactor(data.count, data.type);
                    const cdlPerMeter = data.capacity * demandFactor;
                    const totalCDL = data.count * cdlPerMeter * coincidenceFactor;

                    meters.push({
                        id: Date.now() + Math.random(),
                        type: data.type,
                        typeName: meterTypeNames[data.type],
                        count: data.count,
                        capacity: data.capacity,
                        demandFactor: demandFactor,
                        coincidenceFactor: coincidenceFactor,
                        cdlPerMeter: cdlPerMeter,
                        totalCDL: totalCDL,
                        category: getCategoryForType(data.type),
                        timePattern: getTimePatternForType(data.type)
                    });
                });

                updateMetersList();
                showSuccess('تم إضافة البيانات التجريبية - حمل كبير لاختبار المحولات المتعددة');
            }
        }

        // الوظيفة الرئيسية للتوزيع المتوازن مع المحولات المتعددة
        function calculateBalancedDistribution() {
            if (meters.length === 0) {
                showError('يرجى إضافة العدادات أولاً');
                return;
            }

            document.getElementById('loading').style.display = 'block';
            
            setTimeout(() => {
                try {
                    const results = performBalancedDistributionMultiTransformer();
                    displayResults(results);
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('resultsSection').style.display = 'block';
                    showSuccess(`تم حساب التوزيع المتوازن! عدد المحولات: ${results.transformers.length} - نقاط التوازن: ${results.balanceScore}%`);
                } catch (error) {
                    document.getElementById('loading').style.display = 'none';
                    showError('حدث خطأ في الحسابات: ' + error.message);
                }
            }, 1500);
        }













        // الوظيفة المحدثة للتوزيع على محولات متعددة
        function performBalancedDistributionMultiTransformer() {
            const totalLoad = meters.reduce((sum, meter) => sum + meter.totalCDL, 0);
            
            // تحويل العدادات لقائمة فردية مرتبة حسب الحمل
            const individualMeters = [];
            meters.forEach(meterGroup => {
                const cdlPerMeter = meterGroup.totalCDL / meterGroup.count;
                for (let i = 0; i < meterGroup.count; i++) {
                    individualMeters.push({
                        ...meterGroup,
                        id: `${meterGroup.id}_${i + 1}`,
                        cdl: cdlPerMeter
                    });
                }
            });

            // ترتيب العدادات حسب الحمل (الأكبر أولاً)
            individualMeters.sort((a, b) => b.cdl - a.cdl);

            // توزيع على محولات متعددة
            const transformers = distributeOnMultipleTransformers(individualMeters, totalLoad);
            
            // حساب نقاط التوازن الإجمالية
            const balanceScore = calculateOverallBalanceScore(transformers);
            
            return {
                totalLoad: totalLoad,
                transformers: transformers,
                balanceScore: balanceScore,
                summary: calculateMultiTransformerSummary(transformers, totalLoad, balanceScore)
            };
        }

        function distributeOnMultipleTransformers(individualMeters, totalLoad) {
            const transformers = [];
            let remainingMeters = [...individualMeters];
            let transformerId = 1;

            while (remainingMeters.length > 0) {
                // اختيار المحول المناسب للحمل المتبقي
                const remainingLoad = remainingMeters.reduce((sum, meter) => sum + meter.cdl, 0);
                const selectedTransformerType = selectOptimalTransformerForLoad(remainingLoad);
                
                const transformer = {
                    id: transformerId++,
                    type: selectedTransformerType,
                    assignedLoad: 0,
                    breakers: []
                };

                // إنشاء القواطع للمحول
                const requiredBreakers = Math.ceil(Math.min(remainingLoad, selectedTransformerType.safeLoad) / (MAX_BREAKER_CAPACITY * 0.75));
                const actualBreakers = Math.min(requiredBreakers, selectedTransformerType.breakers);

                for (let i = 1; i <= actualBreakers; i++) {
                    transformer.breakers.push({
                        id: i,
                        number: i,
                        load: 0,
                        meters: [],
                        utilizationPercent: 0,
                        meterTypes: new Set(),
                        categories: new Set(),
                        timePatterns: new Set()
                    });
                }

                // توزيع العدادات على هذا المحول (بحد أقصى 80%)
                const assignedMeters = [];
                let currentTransformerLoad = 0;

                for (let i = remainingMeters.length - 1; i >= 0; i--) {
                    const meter = remainingMeters[i];
                    
                    // التحقق من إمكانية إضافة العداد دون تجاوز 80%
                    if (currentTransformerLoad + meter.cdl <= selectedTransformerType.safeLoad) {
                        assignedMeters.push(meter);
                        currentTransformerLoad += meter.cdl;
                        remainingMeters.splice(i, 1);
                    }
                }

                if (assignedMeters.length > 0) {
                    // توزيع العدادات المخصصة على قواطع المحول
                    distributeMetersOnTransformer(transformer, assignedMeters);
                    transformer.assignedLoad = currentTransformerLoad;
                    transformers.push(transformer);
                } else {
                    // إذا لم نتمكن من تخصيص أي عداد، نكسر الحلقة لتجنب الحلقة اللانهائية
                    break;
                }
            }

            // إذا بقيت عدادات، نحاول توزيعها على المحولات الموجودة
            if (remainingMeters.length > 0) {
                distributeRemainingMeters(transformers, remainingMeters);
            }

            return transformers;
        }

        function selectOptimalTransformerForLoad(load) {
            // البحث عن أصغر محول يمكنه استيعاب الحمل بحد أقصى 80%
            for (let transformer of TRANSFORMER_TYPES) {
                if (load <= transformer.safeLoad) {
                    return transformer;
                }
            }
            
            // إذا كان الحمل كبير جداً، نأخذ أكبر محول متاح
            return TRANSFORMER_TYPES[TRANSFORMER_TYPES.length - 1];
        }

         
         
         
         function distributeMetersOnTransformer(transformer, assignedMeters) {
    if (!Array.isArray(assignedMeters)) {
        console.error('assignedMeters ليست مصفوفة:', assignedMeters);
        return;
    }

    console.log(`🔧 بدء توزيع ${assignedMeters.length} عداد على المحول ${transformer.type.name}`);

    // ترتيب العدادات حسب الحمل (الأكبر أولاً)
    const sortedMeters = assignedMeters.sort((a, b) => b.cdl - a.cdl);

    // تصنيف العدادات حسب السعة
    const largeMeters = sortedMeters.filter(meter => meter.capacity >= 1600);
    const dualBreakerMeters = sortedMeters.filter(meter => meter.capacity >= 500 && meter.capacity < 1600);
    const regularMeters = sortedMeters.filter(meter => meter.capacity < 500);

    console.log(`📊 تصنيف العدادات:
    - كبيرة (≥1600A): ${largeMeters.length}
    - متوسطة (500-1600A): ${dualBreakerMeters.length}
    - عادية (<500A): ${regularMeters.length}`);

    // المرحلة 1: معالجة العدادات الكبيرة (≥1600A) - بدون تغيير
    largeMeters.forEach(meter => {
        const dedicatedBreaker = findEmptyBreaker(transformer.breakers);
        if (dedicatedBreaker) {
            addMeterToBreaker(dedicatedBreaker, meter, transformer.type);
            dedicatedBreaker.dedicated = true;
            dedicatedBreaker.dedicatedFor = `${meter.capacity}A`;
            console.log(`🔥 عداد كبير ${meter.capacity}A → قاطع ${dedicatedBreaker.number} (مخصص)`);
        } else {
            console.warn(`⚠️ لا يوجد قاطع فارغ للعداد الكبير ${meter.capacity}A`);
        }
    });

    // المرحلة 2: معالجة العدادات المتوسطة (500-1600A) - بدون تغيير
    dualBreakerMeters.forEach(meter => {
        const halfLoad = meter.cdl / 2;
        const availableBreakers = transformer.breakers.filter(breaker => 
            !breaker.dedicated && breaker.load + halfLoad <= MAX_BREAKER_CAPACITY
        );

        if (availableBreakers.length >= 2) {
            const bestPair = findBestTwoBreakers(availableBreakers, halfLoad);
            
            if (bestPair.length === 2) {
                addMeterToBreaker(bestPair[0], {
                    ...meter,
                    id: `${meter.id}_part1`,
                    cdl: halfLoad,
                    note: `جزء 1 من عداد ${meter.capacity}A`
                }, transformer.type);
                
                addMeterToBreaker(bestPair[1], {
                    ...meter,
                    id: `${meter.id}_part2`,
                    cdl: halfLoad,
                    note: `جزء 2 من عداد ${meter.capacity}A`
                }, transformer.type);
                
                console.log(`🔄 عداد متوسط ${meter.capacity}A → قاطع ${bestPair[0].number} + قاطع ${bestPair[1].number} (${halfLoad}A لكل منهما)`);
            } else {
                console.warn(`⚠️ لا يمكن توزيع العداد ${meter.capacity}A على قاطعين`);
            }
        } else {
            console.warn(`⚠️ لا يوجد قاطعين متاحين للعداد ${meter.capacity}A`);
        }
    });

    // المرحلة 3: معالجة العدادات العادية (<500A) - مع التعديل الجديد
    regularMeters.forEach(meter => {
        let bestBreaker = null;
        let bestScore = -1;
        
        // تحديد الحد الأقصى للقاطع حسب نوع المحول
        let maxBreakerLoad;
        switch(transformer.type.capacity) {
            case 500:
                maxBreakerLoad = 144.20;
                break;
            case 1000:
                maxBreakerLoad = 144.30;
                break;
            case 1500:
                maxBreakerLoad = 173.12;
                break;
            default:
                maxBreakerLoad = MAX_BREAKER_CAPACITY; // 248 للمحولات الأخرى
        }

        for (let breaker of transformer.breakers) {
            if (breaker.dedicated) continue;

            // استخدام الحد الجديد للتحقق من السعة
            if (breaker.load + meter.cdl <= maxBreakerLoad) {
                const score = calculateBreakerScore(breaker, meter, transformer.breakers, transformer.type);
                if (score > bestScore) {
                    bestScore = score;
                    bestBreaker = breaker;
                }
            }
        }

        if (bestBreaker) {
            addMeterToBreaker(bestBreaker, meter, transformer.type);
            console.log(`✅ عداد ${meter.capacity}A → قاطع ${bestBreaker.number} (${bestBreaker.load.toFixed(2)}A/${maxBreakerLoad}A)`);
        } else {
            console.warn(`⚠️ لا يمكن توزيع العداد ${meter.capacity}A - جميع القواطع ممتلئة`);
        }
    });

    // المرحلة 4: تحسين التوازن النهائي
    console.log('⚖️ تحسين التوازن النهائي...');
    optimizeBalance(transformer.breakers, transformer.type);
    
    console.log(`✅ تم توزيع جميع العدادات على المحول ${transformer.type.name}`);
}

         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         

        function distributeRemainingMeters(transformers, remainingMeters) {
            for (let meter of remainingMeters) {
                let assigned = false;
                
                // محاولة إضافة العداد لأي محول لديه مساحة
                for (let transformer of transformers) {
                    const currentLoad = transformer.assignedLoad;
                    
                    if (currentLoad + meter.cdl <= transformer.type.safeLoad) {
                        // البحث عن قاطع مناسب في هذا المحول
                        for (let breaker of transformer.breakers) {
                            if (breaker.load + meter.cdl <= MAX_BREAKER_CAPACITY) {
                                addMeterToBreaker(breaker, meter);
                                transformer.assignedLoad += meter.cdl;
                                assigned = true;
                                break;
                            }
                        }
                        
                        if (assigned) break;
                    }
                }
                
                // إذا لم نتمكن من تخصيص العداد، نضيف محول جديد
                if (!assigned) {
                    const newTransformerType = selectOptimalTransformerForLoad(meter.cdl);
                    const newTransformer = {
                        id: transformers.length + 1,
                        type: newTransformerType,
                        assignedLoad: meter.cdl,
                        breakers: []
                    };

                    // إنشاء قاطع واحد على الأقل
                    newTransformer.breakers.push({
                        id: 1,
                        number: 1,
                        load: 0,
                        meters: [],
                        utilizationPercent: 0,
                        meterTypes: new Set(),
                        categories: new Set(),
                        timePatterns: new Set()
                    });

                    addMeterToBreaker(newTransformer.breakers[0], meter);
                    transformers.push(newTransformer);
                }
            }
        }

         
         
         
         
         function calculateBreakerScore(breaker, meter, allBreakers, transformerType) {
    let score = 0;
    
    // تحديد الحد الأقصى للقاطع حسب نوع المحول
    let maxBreakerLoad;
    switch(transformerType.capacity) {
        case 500:
            maxBreakerLoad = 144.00;
            break;
        case 1000:
            maxBreakerLoad = 144.30;
            break;
        case 1500:
            maxBreakerLoad = 173.12;
            break;
        default:
            maxBreakerLoad = MAX_BREAKER_CAPACITY; // 248 للمحولات الأخرى
    }
    
    // التحقق من متطلبات العدادات الكبيرة (لا تغيير هنا)
    const meterRequirement = getBreakerRequirementForMeter(meter.capacity);
    
    // للعدادات التي تحتاج قواطع خاصة (1600A أو 2500A) - بدون تغيير
    if (meterRequirement.breakerType === '1600A' || meterRequirement.breakerType === '2500A') {
        if (breaker.meters.length === 0) {
            score += 100;
        } else {
            score -= 50;
        }
        return score;
    }
    
    // للعدادات 500A، 600A، 800A التي تحتاج قاطعين - بدون تغيير
    if (meterRequirement.requiredBreakers === 2) {
        const halfLoad = meter.cdl / 2;
        if (breaker.load + halfLoad <= MAX_BREAKER_CAPACITY) {
            score += 80;
        } else {
            score -= 30;
        }
        return score;
    }

    // للعدادات العادية (20-400A) - استخدام الحد الجديد
    const newUtilization = ((breaker.load + meter.cdl) / maxBreakerLoad) * 100;
    const targetDiff = Math.abs(newUtilization - TARGET_UTILIZATION);
    score += Math.max(0, 50 - targetDiff);

    // نقاط التوازن بين القواطع - استخدام الحد الجديد
    const avgLoad = allBreakers.reduce((sum, b) => sum + b.load, 0) / allBreakers.length;
    const balanceDiff = Math.abs((breaker.load + meter.cdl) - avgLoad);
    score += Math.max(0, 30 - balanceDiff);

    // نقاط الخلط المتنوع - بدون تغيير
    if (!breaker.categories.has(meter.category)) {
        score += 15;
    }
    if (!breaker.timePatterns.has(meter.timePattern)) {
        score += 10;
    }

    // تجنب الازدحام - بدون تغيير
    if (breaker.meters.length >= 6) {
        score -= 20;
    }

    return score;
}

         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
      function addMeterToBreaker(breaker, meter, transformerType = null) {
    const meterRequirement = getBreakerRequirementForMeter(meter.capacity);
    
    // للعدادات الكبيرة (1600A، 2500A) - بدون تغيير
    if (meter.capacity >= 1600) {
        if (breaker.meters.length > 0) {
            console.warn(`⚠️ القاطع ${breaker.number} غير فارغ للعداد الكبير ${meter.capacity}A`);
            return false;
        }
        
        breaker.meters.push({
            ...meter,
            note: `عداد ${meter.capacity}A - قاطع مخصص بالكامل`
        });
        breaker.load = meter.cdl;
        breaker.dedicated = true;
        breaker.dedicatedFor = `${meter.capacity}A`;
        
        updateBreakerStats(breaker, transformerType);
        console.log(`✅ تم تخصيص القاطع ${breaker.number} بالكامل للعداد ${meter.capacity}A (${meter.cdl}A)`);
        return true;
    }
    
    // للعدادات العادية والمتوسطة
    breaker.meters.push(meter);
    breaker.load += meter.cdl;
    updateBreakerStats(breaker, transformerType);
    return true;
}











   
         

         
         
         function optimizeBalance(breakers, transformerType) {
    let improved = true;
    let iterations = 0;

    while (improved && iterations < 10) {
        improved = false;
        iterations++;

        // تحسين التوازن بين القواطع
        for (let i = 0; i < breakers.length; i++) {
            for (let j = i + 1; j < breakers.length; j++) {
                if (tryBalanceBreakers(breakers[i], breakers[j], transformerType)) {
                    improved = true;
                }
            }
        }
    }
}

         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         

        
        
        
        function tryBalanceBreakers(breaker1, breaker2, transformerType) {
    if (breaker1.meters.length === 0 || breaker2.meters.length === 0) return false;

    // تحديد الحد الأقصى حسب نوع المحول
    let maxBreakerLoad = MAX_BREAKER_CAPACITY;
    if (transformerType) {
        switch(transformerType.capacity) {
            case 500:
                maxBreakerLoad = 144.0;
                break;
            case 1000:
                maxBreakerLoad = 144.40;
                break;
            case 1500:
                maxBreakerLoad = 173.12;
                break;
        }
    }

    const currentDiff = Math.abs(breaker1.load - breaker2.load);
    
    // محاولة تبديل العدادات لتحسين التوازن
    for (let meter1 of breaker1.meters) {
        for (let meter2 of breaker2.meters) {
            const newLoad1 = breaker1.load - meter1.cdl + meter2.cdl;
            const newLoad2 = breaker2.load - meter2.cdl + meter1.cdl;
            
            // استخدام الحد الجديد للتحقق
            if (newLoad1 <= maxBreakerLoad && newLoad2 <= maxBreakerLoad) {
                const newDiff = Math.abs(newLoad1 - newLoad2);
                
                if (newDiff < currentDiff - 5) {
                    // تنفيذ التبديل
                    const meter1Index = breaker1.meters.indexOf(meter1);
                    const meter2Index = breaker2.meters.indexOf(meter2);
                    
                    breaker1.meters[meter1Index] = meter2;
                    breaker2.meters[meter2Index] = meter1;
                    
                    updateBreakerStats(breaker1, transformerType);
                    updateBreakerStats(breaker2, transformerType);
                    
                    return true;
                }
            }
        }
    }
    
    // محاولة نقل عداد واحد لتحسين التوازن
    if (breaker1.load > breaker2.load + 20) {
        return tryMoveMeterForBalance(breaker1, breaker2, transformerType);
    } else if (breaker2.load > breaker1.load + 20) {
        return tryMoveMeterForBalance(breaker2, breaker1, transformerType);
    }
    
    return false;
}

        
        
        
        
        
        
        
        
        
        

         
         
         
         
         
         
         
         
         
         function tryMoveMeterForBalance(heavyBreaker, lightBreaker, transformerType) {
    // تحديد الحد الأقصى حسب نوع المحول
    let maxBreakerLoad = MAX_BREAKER_CAPACITY;
    if (transformerType) {
        switch(transformerType.capacity) {
            case 500:
                maxBreakerLoad = 576.80;
                break;
            case 1000:
                maxBreakerLoad = 1154.40;
                break;
            case 1500:
                maxBreakerLoad = 1154.40;
                break;
        }
    }

    let bestMeter = null;
    let bestImprovement = 0;
    
    for (let meter of heavyBreaker.meters) {
        if (lightBreaker.load + meter.cdl <= maxBreakerLoad) {
            const currentDiff = Math.abs(heavyBreaker.load - lightBreaker.load);
            const newHeavyLoad = heavyBreaker.load - meter.cdl;
            const newLightLoad = lightBreaker.load + meter.cdl;
            const newDiff = Math.abs(newHeavyLoad - newLightLoad);
            
            const improvement = currentDiff - newDiff;
            if (improvement > bestImprovement) {
                bestImprovement = improvement;
                bestMeter = meter;
            }
        }
    }
    
    if (bestMeter && bestImprovement > 10) {
        const meterIndex = heavyBreaker.meters.indexOf(bestMeter);
        heavyBreaker.meters.splice(meterIndex, 1);
        lightBreaker.meters.push(bestMeter);
        
        updateBreakerStats(heavyBreaker, transformerType);
        updateBreakerStats(lightBreaker, transformerType);
        
        return true;
    }
    
    return false;
}

         
         
         
         
         
         
         
         
         
         
         

        function updateBreakerStats(breaker, transformerType = null) {
    breaker.load = breaker.meters.reduce((sum, meter) => sum + meter.cdl, 0);
    
    // تحديد الحد الأقصى للحساب حسب نوع المحول
    let maxCapacity = MAX_BREAKER_CAPACITY; // القيمة الافتراضية
    
    if (transformerType) {
        switch(transformerType.capacity) {
            case 500:
                maxCapacity = 576.80;
                break;
            case 1000:
                maxCapacity = 1154.40;
                break;
            case 1500:
                maxCapacity = 1154.40;
                break;
            default:
                maxCapacity = MAX_BREAKER_CAPACITY;
        }
    }
    
    breaker.utilizationPercent = (breaker.load / maxCapacity) * 100;
    
    breaker.meterTypes = new Set();
    breaker.categories = new Set();
    breaker.timePatterns = new Set();
    
    breaker.meters.forEach(meter => {
        breaker.meterTypes.add(meter.type);
        breaker.categories.add(meter.category);
        breaker.timePatterns.add(meter.timePattern);
    });
}


        // دالة للعثور على قاطع فارغ
        function findEmptyBreaker(breakers) {
            return breakers.find(breaker => breaker.meters.length === 0);
        }

        function calculateOverallBalanceScore(transformers) {
            if (transformers.length === 0) return 0;

            let totalScore = 0;
            let totalWeight = 0;

            transformers.forEach(transformer => {
                const transformerScore = calculateTransformerBalanceScore(transformer);
                const weight = transformer.assignedLoad;
                totalScore += transformerScore * weight;
                totalWeight += weight;
            });

            return totalWeight > 0 ? totalScore / totalWeight : 0;
        }

        function calculateTransformerBalanceScore(transformer) {
            const activeBreakers = transformer.breakers.filter(b => b.meters.length > 0);
            if (activeBreakers.length === 0) return 0;

            let totalScore = 0;
            let maxScore = 0;

            // تقييم التوازن في الاستخدام
            const utilizationValues = activeBreakers.map(b => b.utilizationPercent);
            const avgUtilization = utilizationValues.reduce((a, b) => a + b, 0) / utilizationValues.length;
            const utilizationStdDev = Math.sqrt(utilizationValues.reduce((sum, val) => sum + Math.pow(val - avgUtilization, 2), 0) / utilizationValues.length);
            
            // نقاط التوازن (كلما قل الانحراف المعياري، كلما زادت النقاط)
            const balanceScore = Math.max(0, 100 - (utilizationStdDev * 2));
            totalScore += balanceScore * 0.4;
            maxScore += 40;

            // تقييم الاستخدام الأمثل
            let optimalUsageScore = 0;
            activeBreakers.forEach(breaker => {
                const diff = Math.abs(breaker.utilizationPercent - TARGET_UTILIZATION);
                optimalUsageScore += Math.max(0, 100 - (diff * 2));
            });
            optimalUsageScore = optimalUsageScore / activeBreakers.length;
            totalScore += optimalUsageScore * 0.3;
            maxScore += 30;

            // تقييم التنوع في الأحمال
            let diversityScore = 0;
            activeBreakers.forEach(breaker => {
                const categoryCount = breaker.categories.size;
                const timePatternCount = breaker.timePatterns.size;
                diversityScore += Math.min(100, (categoryCount + timePatternCount) * 25);
            });
            diversityScore = diversityScore / activeBreakers.length;
            totalScore += diversityScore * 0.2;
            maxScore += 20;

            // تقييم عدم التحميل الزائد
            const overloadPenalty = activeBreakers.filter(b => b.utilizationPercent > 100).length * 10;
            totalScore -= overloadPenalty;

            // تقييم استخدام المحول (يجب ألا يتجاوز 80%)
            const transformerUtilization = (transformer.assignedLoad / transformer.type.safeLoad) * 100;
            if (transformerUtilization <= 80) {
                totalScore += 10; // مكافأة للالتزام بحد 80%
            } else {
                totalScore -= (transformerUtilization - 80) * 2; // عقوبة للتجاوز
            }

            // تقييم الكفاءة في استخدام القواطع
            const efficiencyScore = (activeBreakers.length / transformer.type.breakers) * 100;
            totalScore += efficiencyScore * 0.1;
            maxScore += 10;

            return Math.max(0, Math.min(100, (totalScore / maxScore) * 100));
        }

        
        function calculateOverallEfficiency(transformers) {
            let totalUsedCapacity = 0;
            let totalAvailableCapacity = 0;

            transformers.forEach(transformer => {
                totalUsedCapacity += transformer.assignedLoad;
                totalAvailableCapacity += transformer.type.safeLoad;
            });

            return totalAvailableCapacity > 0 ? (totalUsedCapacity / totalAvailableCapacity) * 100 : 0;
        }

        function displayResults(results) {
            distributionResults = results;
            
            displaySummary(results.summary);
            displayTransformers(results.transformers);
            displayResultsTable(results.transformers);
        }

        function displaySummary(summary) {
            const summaryGrid = document.getElementById('summaryGrid');
            
            // حساب إجمالي الحمل بـ KVA
            const totalLoadKVA = (summary.totalLoad * 0.4 * 1.73).toFixed(1);
            
            // التحقق من وجود transformers والحصو
            
            let transformerDisplay = '';
            let transformerDetails = '';
            
            if (distributionResults && distributionResults.transformers && distributionResults.transformers.length > 0) {
                // تجميع المحولات حسب السعة
                const transformerCapacities = {};
                distributionResults.transformers.forEach(transformer => {
                    const capacity = transformer.type.capacity;
                    if (transformerCapacities[capacity]) {
                        transformerCapacities[capacity]++;
                    } else {
                        trfunction calculateMultiTransformerSummary(transformers, totalLoad, balanceScore) {
    let totalBreakers = 0;
    let totalMeters = 0;
    let overloadedBreakers = 0;
    let overloadedTransformers = 0;
    let maxUtilization = 0;
    let minUtilization = 100;
    let totalUtilization = 0;
    let utilizationCount = 0;

    // ✅ حساب العدادات من المتغير meters مباشرة
    if (meters && meters.length > 0) {
        totalMeters = meters.reduce((sum, meter) => sum + meter.count, 0);
    }

    transformers.forEach(transformer => {
        const activeBreakers = transformer.breakers.filter(b => b.meters.length > 0);
        totalBreakers += activeBreakers.length;
        
        activeBreakers.forEach(breaker => {
            if (breaker.utilizationPercent > 100) {
                overloadedBreakers++;
            }
            maxUtilization = Math.max(maxUtilization, breaker.utilizationPercent);
            minUtilization = Math.min(minUtilization, breaker.utilizationPercent);
            totalUtilization += breaker.utilizationPercent;
            utilizationCount++;
        });

        // تحقق من تجاوز المحول لحد 80%
        const transformerUtilization = (transformer.assignedLoad / transformer.type.safeLoad) * 100;
        if (transformerUtilization > 100) {
            overloadedTransformers++;
        }
    });

    const avgUtilization = utilizationCount > 0 ? totalUtilization / utilizationCount : 0;

    return {
        totalTransformers: transformers.length,
        totalBreakers,
        totalMeters, // ✅ العدد الصحيح من متغير meters
        totalLoad: totalLoad.toFixed(1),
        overloadedBreakers,
        overloadedTransformers,
        maxUtilization: maxUtilization.toFixed(1),
        minUtilization: minUtilization === 100 ? '0.0' : minUtilization.toFixed(1),
        avgUtilization: avgUtilization.toFixed(1),
        balanceScore: balanceScore.toFixed(1),
        efficiency: calculateOverallEfficiency(transformers).toFixed(1)
    };
}
ansformerCapacities[capacity] = 1;
                    }
                });
                
                // تكوين نص عرض المحولات للبطاقة الأولى (مضغوط)
                transformerDisplay = Object.entries(transformerCapacities)
                                        .sort(([a], [b]) => parseInt(b) - parseInt(a)) // ترتيب تنازلي حسب السعة
                    .map(([capacity, count]) => `<span style="display: inline-block; background: rgba(255,255,255,0.2); padding: 2px 6px; border-radius: 4px; margin: 1px;">${count}x ${capacity} KVA</span>`)
                    .join(' ');
                
                // تكوين تفاصيل المحولات للبطاقة المنفصلة (مفصل)
                transformerDetails = Object.entries(transformerCapacities)
                    .sort(([a], [b]) => parseInt(b) - parseInt(a)) // ترتيب تنازلي حسب السعة
                    .map(([capacity, count]) => `${count}x ${capacity} KVA`)
                    .join('<br>');
            }
            
            summaryGrid.innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${summary.totalTransformers}</div>
                    <div>عدد المحولات</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${summary.totalBreakers}</div>
                    <div>القواطع المستخدمة</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${summary.totalMeters}</div>
                    <div>إجمالي العدادات</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${summary.totalLoad}</div>
                    <div>إجمالي الحمل (أمبير)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${totalLoadKVA}</div>
                    <div>إجمالي الحمل (KVA)</div>
                </div>
                ${transformerDetails ? `
                <div class="stat-card">
                    <div style="font-size: 14px; font-weight: bold; margin-bottom: 8px;">تفاصيل المحولات</div>
                    <div style="font-size: 12px; line-height: 1.6; text-align: center;">
                        ${transformerDetails}
                    </div>
                </div>
                ` : ''}
                <div class="stat-card ${summary.overloadedTransformers > 0 ? 'balance-poor' : 'balance-excellent'}">
                    <div class="stat-number">${summary.overloadedTransformers}</div>
                    <div>محولات محملة زائد</div>
                </div>
                <div class="stat-card ${summary.overloadedBreakers > 0 ? 'balance-poor' : 'balance-excellent'}">
                    <div class="stat-number">${summary.overloadedBreakers}</div>
                    <div>قواطع محملة زائد</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${summary.balanceScore}%</div>
                    <div>نقاط التوازن</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${summary.efficiency}%</div>
                    <div>الكفاءة الإجمالية</div>
                </div>
            `;
        }

        function displayTransformers(transformers) {
            const transformersSection = document.getElementById('transformersSection');
            
            transformersSection.innerHTML = transformers.map((transformer, index) => {
                const activeBreakers = transformer.breakers.filter(b => b.meters.length > 0);
                const transformerUtilization = (transformer.assignedLoad / transformer.type.safeLoad) * 100;
                const transformerStatus = getTransformerStatus(transformerUtilization);
                
                // تمييز المحولات المخصصة
                const dedicatedIcon = transformer.isDedicated ? '🔥 ' : '🔌 ';
                const dedicatedLabel = transformer.isDedicated ? ' (مخصص)' : '';
                const dedicatedStyle = transformer.isDedicated ? 'border: 3px solid #ff6600; background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);' : '';
                
                return `
                    <div class="transformer-section ${transformerStatus.class}" style="${dedicatedStyle}">
                        <h3>${dedicatedIcon}المحول ${index + 1}: ${transformer.type.name}${dedicatedLabel} ${transformerStatus.indicator}</h3>
                        ${transformer.isDedicated ? `
                            <div style="background: #ff6600; color: white; padding: 10px; border-radius: 6px; margin-bottom: 15px; font-weight: bold;">
                                🔥 محول مخصص بالكامل للعداد ${transformer.dedicatedFor} - يستخدم القاطع الرئيسي فقط
                            </div>
                        ` : ''}
                        <div style="margin-bottom: 15px;">
                            <strong>الحمل الإجمالي:</strong> ${transformer.assignedLoad.toFixed(1)}A / ${transformer.type.safeLoad}A (حد 80%)
                            <br>
                            <strong>نسبة الاستخدام:</strong> ${transformerUtilization.toFixed(1)}% ${transformerUtilization > 100 ? '⚠️ تجاوز الحد المسموح' : '✅ ضمن الحد الآمن'}
                            <br>
                            <strong>القواطع المستخدمة:</strong> ${activeBreakers.length} من ${transformer.type.breakers}
                            ${transformer.isDedicated ? '<br><strong>نوع المحول:</strong> مخصص للعدادات الكبيرة' : `<br><strong>مؤشر التوازن:</strong> ${getBalanceIndicator(activeBreakers)}`}
                        </div>
                        ${transformerUtilization > 100 ? `
                            <div class="transformer-overload-warning">
                                ⚠️ تحذير: هذا المحول يعمل بأكثر من 100% من طاقته الآمنة!
                            </div>
                        ` : ''}
                        <div class="breaker-grid">
                            ${activeBreakers.map(breaker => `
                                <div class="breaker-card" style="${breaker.dedicated ? 'border: 2px solid #ff6600; background: #fff8f0;' : ''}">
                                    <h4>⚡ القاطع ${breaker.number} ${breaker.dedicated ? '<span style="background: #ff6600; color: white; padding: 2px 6px; border-radius: 4px; font-size: 12px;">مخصص</span>' : getBalanceLabel(breaker.utilizationPercent)}</h4>
                                    <div><strong>الحمل:</strong> ${breaker.load.toFixed(1)}A / 310A</div>
                                    <div class="progress-bar">
                                        <div class="progress-fill ${getProgressClass(breaker.utilizationPercent)}" 
                                             style="width: ${Math.min((breaker.load / 310) * 100, 100)}%"></div>
                                    </div>
                                    <div><strong>نسبة الاستخدام:</strong> ${((breaker.load / 310) * 100).toFixed(1)}%</div>
                                    <div><strong>عدد العدادات:</strong> ${breaker.meters.length}</div>
                                    ${breaker.dedicated ? 
                                        `<div><strong>نوع القاطع:</strong> ${breaker.status}</div>` :
                                        `<div><strong>تنوع الأحمال:</strong> ${breaker.categories.size} فئات، ${breaker.timePatterns.size} أنماط</div>`
                                    }
                                    <div style="margin-top: 10px;">
                                        ${generateMeterDetailsHTML(breaker)}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function getTransformerStatus(utilization) {
            if (utilization <= 70) {
                return { class: 'transformer-safe', indicator: '<span class="balance-indicator balance-excellent">ممتاز</span>' };
            } else if (utilization <= 85) {
                return { class: 'transformer-safe', indicator: '<span class="balance-indicator balance-good">جيد</span>' };
            } else if (utilization <= 95) {
                return { class: 'transformer-warning', indicator: '<span class="balance-indicator balance-fair">تحذير</span>' };
            } else if (utilization <= 100) {
                return { class: 'transformer-warning', indicator: '<span class="balance-indicator balance-good">حد أقصى آمن</span>' };
            } else {
                return { class: 'transformer-danger', indicator: '<span class="balance-indicator balance-poor">خطر - تجاوز الحد</span>' };
            }
        }

        function getBalanceIndicator(breakers) {
            const utilizationValues = breakers.map(b => b.utilizationPercent);
            const avgUtilization = utilizationValues.reduce((a, b) => a + b, 0) / utilizationValues.length;
            const stdDev = Math.sqrt(utilizationValues.reduce((sum, val) => sum + Math.pow(val - avgUtilization, 2), 0) / utilizationValues.length);
            
            if (stdDev < 10) return '<span class="balance-indicator balance-excellent">ممتاز</span>';
            if (stdDev < 20) return '<span class="balance-indicator balance-good">جيد</span>';
            if (stdDev < 30) return '<span class="balance-indicator balance-fair">مقبول</span>';
            return '<span class="balance-indicator balance-poor">يحتاج تحسين</span>';
        }

        function getBalanceLabel(utilization) {
            // التأكد من أن utilization رقم صحيح
            const util = parseFloat(utilization);
            
            // التحقق من صحة القيمة
            if (isNaN(util) || util < 0) {
                return '<span class="balance-indicator balance-poor">❌ قيمة غير صحيحة</span>';
            }
            
            // تصنيف التوازن بناءً على النسبة المئوية مباشرة (من 310A)
            // حيث أن utilization هو النسبة من 310A وليس من 248A
            
            if (util >= 70 && util <= 80) {
                return '<span class="balance-indicator balance-excellent">⭐ توازن مثالي</span>';
            }
            else if (util >= 60 && util < 70) {
                return '<span class="balance-indicator balance-good">✅ جيد</span>';
            }
            else if (util >= 50 && util < 60) {
                return '<span class="balance-indicator balance-fair">⚠️ مقبول</span>';
            }
            else if (util < 50) {
                return '<span class="balance-indicator balance-poor">📉 منخفض</span>';
            }
            else {
                return '<span class="balance-indicator balance-poor">🔴 مرتفع</span>';
            }
        }

        function getProgressClass(utilization) {
            // حساب النسبة من 310A
            const utilizationFrom310 = utilization * (248 / 310);
            
            if (utilizationFrom310 <= 75) return 'progress-balanced';  // أخضر
            if (utilizationFrom310 <= 85) return 'progress-good';      // أخضر فاتح  
            if (utilizationFrom310 > 95) return 'progress-high';       // أحمر
            return 'progress-medium';  // برتقالي
        }

        function displayResultsTable(transformers) {
            const resultsBody = document.getElementById('resultsBody');
            
            let tableRows = '';
            
            transformers.forEach((transformer, transformerIndex) => {
                const activeBreakers = transformer.breakers.filter(b => b.meters.length > 0);
                activeBreakers.forEach(breaker => {
                    const loadTypeIndicator = breaker.categories.size > 1 ? 
                        '<span class="mixed-load-indicator">مختلط</span>' : '';
                    const balanceIndicator = getBalanceLabel(breaker.utilizationPercent);
                    
                    tableRows += `
                        <tr>
                            <td>المحول ${transformerIndex + 1}<br><small>${transformer.type.name}</small></td>
                            <td>قاطع ${breaker.number}</td>
                            <td>${loadTypeIndicator}${Array.from(breaker.categories).join(', ')}</td>
                            <td>${breaker.meters.length}</td>
                            <td>${breaker.load.toFixed(1)}A</td>
                            <td>${breaker.utilizationPercent.toFixed(1)}%</td>
                            <td>${balanceIndicator}</td>
                            <td>${generateMeterDetailsHTML(breaker)}</td>
                        </tr>
                    `;
                });
            });
            
            resultsBody.innerHTML = tableRows;
        }

        function generateMeterDetailsHTML(breaker) {
            const meterGroups = {};
            
            breaker.meters.forEach(meter => {
                const key = `${meter.type}_${meter.capacity}`;
                if (!meterGroups[key]) {
                    meterGroups[key] = {
                        type: meter.type,
                        typeName: meter.typeName,
                        capacity: meter.capacity,
                        count: 0,
                        totalCDL: 0,
                        notes: []
                    };
                }
                meterGroups[key].count++;
                meterGroups[key].totalCDL += meter.cdl;
                
                if (meter.note) {
                    meterGroups[key].notes.push(meter.note);
                }
            });

            return Object.values(meterGroups).map(group => {
                const specialNote = group.capacity >= 500 ? 
                    `<br><small style="color: #ff6600;">${group.capacity >= 1600 ? 'قاطع مخصص' : 'موزع على قاطعين'}</small>` : '';
                
                return `
                    <div class="meter-detail-item">
                        <span style="font-size: 16px; color: #1976d2;">${group.count}</span>
                        <span style="margin: 0 3px;">×</span>
                        <span style="font-size: 14px; color: #d32f2f;">${group.capacity}A</span>
                        ${specialNote}
                        <br>
                        <small style="color: #666;">${group.typeName}</small>
                    </div>
                `;
            }).join('');
        }

        function exportToExcel() {
            if (!distributionResults) {
                showError('لا توجد نتائج للتصدير');
                return;
            }
            
            let csvContent = "المحول,القاطع,نوع الأحمال,عدد العدادات,الحمل (A),نسبة الاستخدام (%),مؤشر التوازن,تفاصيل العدادات\n";
            
            distributionResults.transformers.forEach((transformer, transformerIndex) => {
                const activeBreakers = transformer.breakers.filter(b => b.meters.length > 0);
                activeBreakers.forEach(breaker => {
                    const meterTypes = Array.from(breaker.categories).join(' + ');
                    const balanceText = getBalanceText(breaker.utilizationPercent);
                    const meterDetails = breaker.meters.map(meter => 
                        `${meter.typeName} (${meter.capacity}A)`
                    ).join(' | ');
                    
                    csvContent += `"المحول ${transformerIndex + 1} - ${transformer.type.name}",قاطع ${breaker.number},"${meterTypes}",${breaker.meters.length},${breaker.load.toFixed(1)},${breaker.utilizationPercent.toFixed(1)},"${balanceText}","${meterDetails}"\n`;
                });
            });
            
            // إضافة ملخص التوازن
            csvContent += `\nملخص التوازن:\n`;
            csvContent += `عدد المحولات,${distributionResults.summary.totalTransformers}\n`;
            csvContent += `نقاط التوازن,${distributionResults.balanceScore}%\n`;
            csvContent += `الكفاءة الإجمالية,${distributionResults.summary.efficiency}%\n`;
            csvContent += `محولات محملة زائد,${distributionResults.summary.overloadedTransformers}\n`;
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `التوزيع_المتوازن_متعدد_المحولات_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showSuccess('تم تصدير النتائج المتوازنة بنجاح');
        }

        function getBalanceText(utilization) {
            const diff = Math.abs(utilization - TARGET_UTILIZATION);
            if (diff <= 10) return 'متوازن ممتاز';
            if (diff <= 20) return 'متوازن جيد';
            if (diff <= 30) return 'متوازن مقبول';
            return 'غير متوازن';
        }

        function printResults() {
            if (!distributionResults) {
                showError('لا توجد نتائج للطباعة');
                return;
            }
            
            const printWindow = window.open('', '_blank');
            const printContent = `
                <!DOCTYPE html>
                <html dir="rtl">
                <head>
                    <meta charset="UTF-8">
                    <title>تقرير التوزيع المتوازن للعدادات - محولات متعددة</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        h1, h2, h3 { color: #333; }
                        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
                        th { background-color: #4facfe; color: white; }
                        .balance-excellent { background-color: #4caf50; color: white; padding: 4px 8px; border-radius: 4px; }
                        .balance-good { background-color: #8bc34a; color: white; padding: 4px 8px; border-radius: 4px; }
                        .balance-fair { background-color: #ff9800; color: white; padding: 4px 8px; border-radius: 4px; }
                        .balance-poor { background-color: #f44336; color: white; padding: 4px 8px; border-radius: 4px; }
                        .summary { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin: 20px 0; }
                        .stat-card { border: 2px solid #4facfe; padding: 15px; text-align: center; border-radius: 8px; }
                        .transformer-summary { background: #f8f9fa; padding: 15px; margin: 10px 0; border-radius: 8px; }
                        .warning { background-color: #fff3cd; border: 1px solid #ffc107; color: #856404; padding: 10px; border-radius: 4px; margin: 10px 0; }
                        .safe { background-color: #d4edda; border: 1px solid #c3e6cb; color: #155724; padding: 10px; border-radius: 4px; margin: 10px 0; }
                    </style>
                </head>
                <body>
                    <h1>⚖️ تقرير التوزيع المتوازن للعدادات - محولات متعددة</h1>
                    <p><strong>تاريخ التقرير:</strong> ${new Date().toLocaleDateString('ar-SA')}</p>
                    <p><strong>نقاط التوازن الإجمالية:</strong> ${distributionResults.balanceScore}%</p>
                    
                    <h2>📊 ملخص النتائج الإجمالي</h2>
                    <div class="summary">
                        <div class="stat-card">
                            <h3>${distributionResults.summary.totalTransformers}</h3>
                            <p>عدد المحولات</p>
                        </div>
                        <div class="stat-card">
                            <h3>${distributionResults.summary.totalBreakers}</h3>
                            <p>إجمالي القواطع</p>
                        </div>
                        <div class="stat-card">
                            <h3>${distributionResults.summary.totalMeters}</h3>
                            <p>إجمالي العدادات</p>
                        </div>
                        <div class="stat-card">
                            <h3>${distributionResults.summary.efficiency}%</h3>
                            <p>الكفاءة الإجمالية</p>
                        </div>
                    </div>
                    
                    <h2>🔌 تفاصيل المحولات</h2>
                    ${distributionResults.transformers.map((transformer, index) => {
                        const transformerUtilization = (transformer.assignedLoad / transformer.type.safeLoad) * 100;
                        const isOverloaded = transformerUtilization > 100;
                        
                        return `
                            <div class="transformer-summary">
                                <h3>المحول ${index + 1}: ${transformer.type.name}</h3>
                                <div class="${isOverloaded ? 'warning' : 'safe'}">
                                    <strong>الحمل:</strong> ${transformer.assignedLoad.toFixed(1)}A / ${transformer.type.safeLoad}A<br>
                                    <strong>نسبة الاستخدام:</strong> ${transformerUtilization.toFixed(1)}%<br>
                                    <strong>الحالة:</strong> ${isOverloaded ? '⚠️ يتجاوز الحد الآمن (100%)' : '✅ ضمن الحد الآمن'}
                                </div>
                            </div>
                        `;
                    }).join('')}
                    
                    <h2>📋 تفاصيل التوزيع المتوازن</h2>
                    ${document.getElementById('resultsTable').outerHTML}
                    
                    <h2>📈 تحليل الأداء</h2>
                    <div style="margin: 20px 0;">
                        <p><strong>المحولات المحملة زائد:</strong> ${distributionResults.summary.overloadedTransformers} من ${distributionResults.summary.totalTransformers}</p>
                        <p><strong>القواطع المحملة زائد:</strong> ${distributionResults.summary.overloadedBreakers} من ${distributionResults.summary.totalBreakers}</p>
                        <p><strong>متوسط استخدام القواطع:</strong> ${distributionResults.summary.avgUtilization}%</p>
                        <p><strong>أقصى استخدام:</strong> ${distributionResults.summary.maxUtilization}%</p>
                        <p><strong>أدنى استخدام:</strong> ${distributionResults.summary.minUtilization}%</p>
                    </div>
                </body>
                </html>
            `;
            
            printWindow.document.write(printContent);
            printWindow.document.close();
            printWindow.print();
            
            showSuccess('تم إعداد التقرير المتوازن للطباعة');
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'alert alert-error';
            errorDiv.innerHTML = `⚠️ ${message}`;
            errorDiv.style.position = 'fixed';
            errorDiv.style.top = '20px';
            errorDiv.style.right = '20px';
            errorDiv.style.zIndex = '9999';
            errorDiv.style.maxWidth = '400px';
            errorDiv.style.borderRadius = '8px';
            errorDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            
            document.body.appendChild(errorDiv);
            
            setTimeout(() => {
                if (document.body.contains(errorDiv)) {
                    document.body.removeChild(errorDiv);
                }
            }, 5000);
        }

        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'alert alert-success';
            successDiv.innerHTML = `✅ ${message}`;
            successDiv.style.position = 'fixed';
            successDiv.style.top = '20px';
            successDiv.style.right = '20px';
            successDiv.style.zIndex = '9999';
            successDiv.style.maxWidth = '400px';
            successDiv.style.borderRadius = '8px';
            successDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            
            document.body.appendChild(successDiv);
            
            setTimeout(() => {
                if (document.body.contains(successDiv)) {
                    document.body.removeChild(successDiv);
                }
            }, 3000);
        }

        // تهيئة الصفحة
        document.addEventListener('DOMContentLoaded', function() {
            updateMetersList();
            
            document.getElementById('meterCount').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    addMeter();
                }
            });
        });
    </script>
</body>
</html>
